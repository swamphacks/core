// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: applications.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
    user_id, event_id
) VALUES (
    $1, $2
)
RETURNING user_id, event_id, status, application, created_at, saved_at, updated_at, submitted_at, experience_rating, passion_rating, assigned_reviewer
`

type CreateApplicationParams struct {
	UserID  uuid.UUID `json:"user_id"`
	EventID uuid.UUID `json:"event_id"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, createApplication, arg.UserID, arg.EventID)
	var i Application
	err := row.Scan(
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.Application,
		&i.CreatedAt,
		&i.SavedAt,
		&i.UpdatedAt,
		&i.SubmittedAt,
		&i.ExperienceRating,
		&i.PassionRating,
		&i.AssignedReviewer,
	)
	return i, err
}

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications
WHERE user_id = $1 AND event_id = $2
`

type DeleteApplicationParams struct {
	UserID  uuid.UUID `json:"user_id"`
	EventID uuid.UUID `json:"event_id"`
}

func (q *Queries) DeleteApplication(ctx context.Context, arg DeleteApplicationParams) error {
	_, err := q.db.Exec(ctx, deleteApplication, arg.UserID, arg.EventID)
	return err
}

const getApplicationByUserAndEventID = `-- name: GetApplicationByUserAndEventID :one
SELECT user_id, event_id, status, application, created_at, saved_at, updated_at, submitted_at, experience_rating, passion_rating, assigned_reviewer FROM applications
WHERE user_id = $1 AND event_id = $2
`

type GetApplicationByUserAndEventIDParams struct {
	UserID  uuid.UUID `json:"user_id"`
	EventID uuid.UUID `json:"event_id"`
}

func (q *Queries) GetApplicationByUserAndEventID(ctx context.Context, arg GetApplicationByUserAndEventIDParams) (Application, error) {
	row := q.db.QueryRow(ctx, getApplicationByUserAndEventID, arg.UserID, arg.EventID)
	var i Application
	err := row.Scan(
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.Application,
		&i.CreatedAt,
		&i.SavedAt,
		&i.UpdatedAt,
		&i.SubmittedAt,
		&i.ExperienceRating,
		&i.PassionRating,
		&i.AssignedReviewer,
	)
	return i, err
}

const updateApplication = `-- name: UpdateApplication :exec
UPDATE applications
SET
    status = CASE WHEN $1::boolean THEN $2::application_status ELSE status END,
    application = CASE WHEN $3::boolean THEN $4::JSONB ELSE application END,
    submitted_at = CASE WHEN $5::boolean THEN $6::timestamptz ELSE submitted_at END,
    saved_at = CASE WHEN $7::boolean THEN $8::timestamptz ELSE saved_at END
WHERE
    user_id = $9 AND event_id = $10
`

type UpdateApplicationParams struct {
	StatusDoUpdate      bool              `json:"status_do_update"`
	Status              ApplicationStatus `json:"status"`
	ApplicationDoUpdate bool              `json:"application_do_update"`
	Application         []byte            `json:"application"`
	SubmittedAtDoUpdate bool              `json:"submitted_at_do_update"`
	SubmittedAt         time.Time         `json:"submitted_at"`
	SavedAtDoUpdate     bool              `json:"saved_at_do_update"`
	SavedAt             time.Time         `json:"saved_at"`
	UserID              uuid.UUID         `json:"user_id"`
	EventID             uuid.UUID         `json:"event_id"`
}

func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) error {
	_, err := q.db.Exec(ctx, updateApplication,
		arg.StatusDoUpdate,
		arg.Status,
		arg.ApplicationDoUpdate,
		arg.Application,
		arg.SubmittedAtDoUpdate,
		arg.SubmittedAt,
		arg.SavedAtDoUpdate,
		arg.SavedAt,
		arg.UserID,
		arg.EventID,
	)
	return err
}
