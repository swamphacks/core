// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ApplicationStatus string

const (
	ApplicationStatusStarted     ApplicationStatus = "started"
	ApplicationStatusSubmitted   ApplicationStatus = "submitted"
	ApplicationStatusUnderReview ApplicationStatus = "under_review"
	ApplicationStatusAccepted    ApplicationStatus = "accepted"
	ApplicationStatusRejected    ApplicationStatus = "rejected"
	ApplicationStatusWaitlisted  ApplicationStatus = "waitlisted"
	ApplicationStatusWithdrawn   ApplicationStatus = "withdrawn"
)

func (e *ApplicationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ApplicationStatus(s)
	case string:
		*e = ApplicationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ApplicationStatus: %T", src)
	}
	return nil
}

type NullApplicationStatus struct {
	ApplicationStatus ApplicationStatus `json:"application_status"`
	Valid             bool              `json:"valid"` // Valid is true if ApplicationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullApplicationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ApplicationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ApplicationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullApplicationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ApplicationStatus), nil
}

type AuthUserRole string

const (
	AuthUserRoleUser      AuthUserRole = "user"
	AuthUserRoleSuperuser AuthUserRole = "superuser"
)

func (e *AuthUserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthUserRole(s)
	case string:
		*e = AuthUserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthUserRole: %T", src)
	}
	return nil
}

type NullAuthUserRole struct {
	AuthUserRole AuthUserRole `json:"auth_user_role"`
	Valid        bool         `json:"valid"` // Valid is true if AuthUserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.AuthUserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthUserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthUserRole), nil
}

type BatRunStatus string

const (
	BatRunStatusRunning   BatRunStatus = "running"
	BatRunStatusCompleted BatRunStatus = "completed"
	BatRunStatusFailed    BatRunStatus = "failed"
)

func (e *BatRunStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BatRunStatus(s)
	case string:
		*e = BatRunStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BatRunStatus: %T", src)
	}
	return nil
}

type NullBatRunStatus struct {
	BatRunStatus BatRunStatus `json:"bat_run_status"`
	Valid        bool         `json:"valid"` // Valid is true if BatRunStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBatRunStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BatRunStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BatRunStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBatRunStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BatRunStatus), nil
}

type EventRoleType string

const (
	EventRoleTypeAdmin     EventRoleType = "admin"
	EventRoleTypeStaff     EventRoleType = "staff"
	EventRoleTypeAttendee  EventRoleType = "attendee"
	EventRoleTypeApplicant EventRoleType = "applicant"
)

func (e *EventRoleType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventRoleType(s)
	case string:
		*e = EventRoleType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventRoleType: %T", src)
	}
	return nil
}

type NullEventRoleType struct {
	EventRoleType EventRoleType `json:"event_role_type"`
	Valid         bool          `json:"valid"` // Valid is true if EventRoleType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventRoleType) Scan(value interface{}) error {
	if value == nil {
		ns.EventRoleType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventRoleType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventRoleType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventRoleType), nil
}

type GetEventScopeType string

const (
	GetEventScopeTypePublished GetEventScopeType = "published"
	GetEventScopeTypeScoped    GetEventScopeType = "scoped"
	GetEventScopeTypeAll       GetEventScopeType = "all"
)

func (e *GetEventScopeType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GetEventScopeType(s)
	case string:
		*e = GetEventScopeType(s)
	default:
		return fmt.Errorf("unsupported scan type for GetEventScopeType: %T", src)
	}
	return nil
}

type NullGetEventScopeType struct {
	GetEventScopeType GetEventScopeType `json:"get_event_scope_type"`
	Valid             bool              `json:"valid"` // Valid is true if GetEventScopeType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGetEventScopeType) Scan(value interface{}) error {
	if value == nil {
		ns.GetEventScopeType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GetEventScopeType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGetEventScopeType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GetEventScopeType), nil
}

type InvitationStatus string

const (
	InvitationStatusPENDING  InvitationStatus = "PENDING"
	InvitationStatusACCEPTED InvitationStatus = "ACCEPTED"
	InvitationStatusEXPIRED  InvitationStatus = "EXPIRED"
	InvitationStatusREJECTED InvitationStatus = "REJECTED"
)

func (e *InvitationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvitationStatus(s)
	case string:
		*e = InvitationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvitationStatus: %T", src)
	}
	return nil
}

type NullInvitationStatus struct {
	InvitationStatus InvitationStatus `json:"invitation_status"`
	Valid            bool             `json:"valid"` // Valid is true if InvitationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvitationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvitationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvitationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvitationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvitationStatus), nil
}

type JoinRequestStatus string

const (
	JoinRequestStatusPENDING  JoinRequestStatus = "PENDING"
	JoinRequestStatusAPPROVED JoinRequestStatus = "APPROVED"
	JoinRequestStatusREJECTED JoinRequestStatus = "REJECTED"
)

func (e *JoinRequestStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JoinRequestStatus(s)
	case string:
		*e = JoinRequestStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JoinRequestStatus: %T", src)
	}
	return nil
}

type NullJoinRequestStatus struct {
	JoinRequestStatus JoinRequestStatus `json:"join_request_status"`
	Valid             bool              `json:"valid"` // Valid is true if JoinRequestStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJoinRequestStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JoinRequestStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JoinRequestStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJoinRequestStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JoinRequestStatus), nil
}

type Application struct {
	UserID             uuid.UUID             `json:"user_id"`
	EventID            uuid.UUID             `json:"event_id"`
	Status             NullApplicationStatus `json:"status"`
	Application        []byte                `json:"application"`
	CreatedAt          time.Time             `json:"created_at"`
	SavedAt            time.Time             `json:"saved_at"`
	UpdatedAt          time.Time             `json:"updated_at"`
	SubmittedAt        *time.Time            `json:"submitted_at"`
	ExperienceRating   *int32                `json:"experience_rating"`
	PassionRating      *int32                `json:"passion_rating"`
	AssignedReviewerID *uuid.UUID            `json:"assigned_reviewer_id"`
	WaitlistJoinTime   *time.Time            `json:"waitlist_join_time"`
}

type AuthAccount struct {
	ID                    uuid.UUID  `json:"id"`
	UserID                uuid.UUID  `json:"user_id"`
	ProviderID            string     `json:"provider_id"`
	AccountID             string     `json:"account_id"`
	HashedPassword        *string    `json:"hashed_password"`
	AccessToken           *string    `json:"access_token"`
	RefreshToken          *string    `json:"refresh_token"`
	IDToken               *string    `json:"id_token"`
	AccessTokenExpiresAt  *time.Time `json:"access_token_expires_at"`
	RefreshTokenExpiresAt *time.Time `json:"refresh_token_expires_at"`
	Scope                 *string    `json:"scope"`
	CreatedAt             time.Time  `json:"created_at"`
	UpdatedAt             time.Time  `json:"updated_at"`
}

type AuthSession struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	ExpiresAt  time.Time `json:"expires_at"`
	IpAddress  *string   `json:"ip_address"`
	UserAgent  *string   `json:"user_agent"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	LastUsedAt time.Time `json:"last_used_at"`
}

type AuthUser struct {
	ID             uuid.UUID    `json:"id"`
	Name           string       `json:"name"`
	Email          *string      `json:"email"`
	EmailVerified  bool         `json:"email_verified"`
	Onboarded      bool         `json:"onboarded"`
	Image          *string      `json:"image"`
	CreatedAt      time.Time    `json:"created_at"`
	UpdatedAt      time.Time    `json:"updated_at"`
	Role           AuthUserRole `json:"role"`
	PreferredEmail *string      `json:"preferred_email"`
	EmailConsent   bool         `json:"email_consent"`
}

type BatRun struct {
	ID                 uuid.UUID        `json:"id"`
	EventID            uuid.UUID        `json:"event_id"`
	AcceptedApplicants []uuid.UUID      `json:"accepted_applicants"`
	RejectedApplicants []uuid.UUID      `json:"rejected_applicants"`
	Status             NullBatRunStatus `json:"status"`
	CreatedAt          time.Time        `json:"created_at"`
	CompletedAt        *time.Time       `json:"completed_at"`
}

type Event struct {
	ID                       uuid.UUID  `json:"id"`
	Name                     string     `json:"name"`
	Description              *string    `json:"description"`
	Location                 *string    `json:"location"`
	LocationUrl              *string    `json:"location_url"`
	MaxAttendees             *int32     `json:"max_attendees"`
	ApplicationOpen          time.Time  `json:"application_open"`
	ApplicationClose         time.Time  `json:"application_close"`
	RsvpDeadline             *time.Time `json:"rsvp_deadline"`
	DecisionRelease          *time.Time `json:"decision_release"`
	StartTime                time.Time  `json:"start_time"`
	EndTime                  time.Time  `json:"end_time"`
	WebsiteUrl               *string    `json:"website_url"`
	IsPublished              *bool      `json:"is_published"`
	CreatedAt                *time.Time `json:"created_at"`
	UpdatedAt                *time.Time `json:"updated_at"`
	Banner                   *string    `json:"banner"`
	ApplicationReviewStarted bool       `json:"application_review_started"`
}

type EventInterestSubmission struct {
	ID        uuid.UUID `json:"id"`
	EventID   uuid.UUID `json:"event_id"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	Source    *string   `json:"source"`
}

type EventRole struct {
	UserID      uuid.UUID     `json:"user_id"`
	EventID     uuid.UUID     `json:"event_id"`
	Role        EventRoleType `json:"role"`
	AssignedAt  *time.Time    `json:"assigned_at"`
	CheckedInAt *time.Time    `json:"checked_in_at"`
	Rfid        *string       `json:"rfid"`
}

type Redeemable struct {
	ID            uuid.UUID          `json:"id"`
	EventID       uuid.UUID          `json:"event_id"`
	Name          string             `json:"name"`
	Amount        int32              `json:"amount"`
	MaxUserAmount int32              `json:"max_user_amount"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type Team struct {
	ID        uuid.UUID  `json:"id"`
	Name      string     `json:"name"`
	OwnerID   *uuid.UUID `json:"owner_id"`
	EventID   *uuid.UUID `json:"event_id"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type TeamInvitation struct {
	ID              uuid.UUID        `json:"id"`
	TeamID          uuid.UUID        `json:"team_id"`
	InvitedByUserID uuid.UUID        `json:"invited_by_user_id"`
	InvitedEmail    string           `json:"invited_email"`
	InvitedUserID   *uuid.UUID       `json:"invited_user_id"`
	Status          InvitationStatus `json:"status"`
	ExpiresAt       *time.Time       `json:"expires_at"`
	CreatedAt       time.Time        `json:"created_at"`
	UpdatedAt       time.Time        `json:"updated_at"`
}

type TeamJoinRequest struct {
	ID                uuid.UUID         `json:"id"`
	TeamID            uuid.UUID         `json:"team_id"`
	UserID            uuid.UUID         `json:"user_id"`
	RequestMessage    *string           `json:"request_message"`
	Status            JoinRequestStatus `json:"status"`
	ProcessedByUserID *uuid.UUID        `json:"processed_by_user_id"`
	ProcessedAt       *time.Time        `json:"processed_at"`
	CreatedAt         time.Time         `json:"created_at"`
	UpdatedAt         time.Time         `json:"updated_at"`
}

type TeamMember struct {
	UserID   uuid.UUID  `json:"user_id"`
	TeamID   uuid.UUID  `json:"team_id"`
	JoinedAt *time.Time `json:"joined_at"`
}

type UserRedemption struct {
	UserID       uuid.UUID          `json:"user_id"`
	RedeemableID uuid.UUID          `json:"redeemable_id"`
	Amount       int32              `json:"amount"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}
