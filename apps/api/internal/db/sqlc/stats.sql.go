// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stats.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const getApplicationAgeSplit = `-- name: GetApplicationAgeSplit :one
SELECT
    COUNT(*) FILTER (WHERE (application->>'age')::int < 18) AS underage,
    COUNT(*) FILTER (WHERE (application->>'age')::int = 18) AS age_18,
    COUNT(*) FILTER (WHERE (application->>'age')::int = 19) AS age_19,
    COUNT(*) FILTER (WHERE (application->>'age')::int = 20) AS age_20,
    COUNT(*) FILTER (WHERE (application->>'age')::int = 21) AS age_21,
    COUNT(*) FILTER (WHERE (application->>'age')::int = 22) AS age_22,
    COUNT(*) FILTER (WHERE (application->>'age')::int >= 23) AS age_23_plus
FROM applications
WHERE status = 'submitted'
  AND event_id = $1
`

type GetApplicationAgeSplitRow struct {
	Underage  int64 `json:"underage"`
	Age18     int64 `json:"age_18"`
	Age19     int64 `json:"age_19"`
	Age20     int64 `json:"age_20"`
	Age21     int64 `json:"age_21"`
	Age22     int64 `json:"age_22"`
	Age23Plus int64 `json:"age_23_plus"`
}

func (q *Queries) GetApplicationAgeSplit(ctx context.Context, eventID uuid.UUID) (GetApplicationAgeSplitRow, error) {
	row := q.db.QueryRow(ctx, getApplicationAgeSplit, eventID)
	var i GetApplicationAgeSplitRow
	err := row.Scan(
		&i.Underage,
		&i.Age18,
		&i.Age19,
		&i.Age20,
		&i.Age21,
		&i.Age22,
		&i.Age23Plus,
	)
	return i, err
}

const getApplicationGenderSplit = `-- name: GetApplicationGenderSplit :one

SELECT
  COUNT(*) FILTER (WHERE application->>'gender' = 'man') AS male,
  COUNT(*) FILTER (WHERE application->>'gender' = 'woman') AS female,
  COUNT(*) FILTER (WHERE application->>'gender' = 'non-binary') AS non_binary,
  COUNT(*) FILTER (WHERE application->>'gender' = '') AS other
FROM applications
WHERE status = 'submitted'
  AND event_id = $1
`

type GetApplicationGenderSplitRow struct {
	Male      int64 `json:"male"`
	Female    int64 `json:"female"`
	NonBinary int64 `json:"non_binary"`
	Other     int64 `json:"other"`
}

// Queries used for statistics, mainly used by overview dashboards etc
func (q *Queries) GetApplicationGenderSplit(ctx context.Context, eventID uuid.UUID) (GetApplicationGenderSplitRow, error) {
	row := q.db.QueryRow(ctx, getApplicationGenderSplit, eventID)
	var i GetApplicationGenderSplitRow
	err := row.Scan(
		&i.Male,
		&i.Female,
		&i.NonBinary,
		&i.Other,
	)
	return i, err
}

const getApplicationMajorSplit = `-- name: GetApplicationMajorSplit :many
SELECT
    trim(major) AS major,
    COUNT(*) AS count
FROM applications,
LATERAL unnest(string_to_array(application->>'majors', ',')) AS major
WHERE status = 'submitted'
  AND event_id = $1
GROUP BY trim(major)
ORDER BY count DESC
`

type GetApplicationMajorSplitRow struct {
	Major string `json:"major"`
	Count int64  `json:"count"`
}

func (q *Queries) GetApplicationMajorSplit(ctx context.Context, eventID uuid.UUID) ([]GetApplicationMajorSplitRow, error) {
	rows, err := q.db.Query(ctx, getApplicationMajorSplit, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetApplicationMajorSplitRow{}
	for rows.Next() {
		var i GetApplicationMajorSplitRow
		if err := rows.Scan(&i.Major, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationRaceSplit = `-- name: GetApplicationRaceSplit :many
SELECT
    CASE 
        WHEN application->>'race' IS NOT NULL AND application->>'race' <> '' THEN application->>'race'
        WHEN application->>'race-other' IS NOT NULL AND application->>'race-other' <> '' THEN application->>'race-other'
        ELSE 'prefer_not_to_say'
    END AS race_group,
    COUNT(*) AS count
FROM applications
WHERE status = 'submitted'
  AND event_id = $1
GROUP BY 
    CASE 
        WHEN application->>'race' IS NOT NULL AND application->>'race' <> '' THEN application->>'race'
        WHEN application->>'race-other' IS NOT NULL AND application->>'race-other' <> '' THEN application->>'race-other'
        ELSE 'prefer_not_to_say'
    END
ORDER BY count DESC
`

type GetApplicationRaceSplitRow struct {
	RaceGroup string `json:"race_group"`
	Count     int64  `json:"count"`
}

func (q *Queries) GetApplicationRaceSplit(ctx context.Context, eventID uuid.UUID) ([]GetApplicationRaceSplitRow, error) {
	rows, err := q.db.Query(ctx, getApplicationRaceSplit, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetApplicationRaceSplitRow{}
	for rows.Next() {
		var i GetApplicationRaceSplitRow
		if err := rows.Scan(&i.RaceGroup, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationSchoolSplit = `-- name: GetApplicationSchoolSplit :many
SELECT
    (application->>'school')::text AS school,
    COUNT(*) AS count
FROM applications
WHERE status = 'submitted'
  AND event_id = $1
GROUP BY (application->>'school')::text
ORDER BY count DESC
`

type GetApplicationSchoolSplitRow struct {
	School string `json:"school"`
	Count  int64  `json:"count"`
}

func (q *Queries) GetApplicationSchoolSplit(ctx context.Context, eventID uuid.UUID) ([]GetApplicationSchoolSplitRow, error) {
	rows, err := q.db.Query(ctx, getApplicationSchoolSplit, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetApplicationSchoolSplitRow{}
	for rows.Next() {
		var i GetApplicationSchoolSplitRow
		if err := rows.Scan(&i.School, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationStatusSplit = `-- name: GetApplicationStatusSplit :one
SELECT
    COUNT(*) FILTER (WHERE status = 'started')       AS started,
    COUNT(*) FILTER (WHERE status = 'submitted')     AS submitted,
    COUNT(*) FILTER (WHERE status = 'under_review')  AS under_review,
    COUNT(*) FILTER (WHERE status = 'accepted')      AS accepted,
    COUNT(*) FILTER (WHERE status = 'rejected')      AS rejected,
    COUNT(*) FILTER (WHERE status = 'waitlisted')    AS waitlisted,
    COUNT(*) FILTER (WHERE status = 'withdrawn')     AS withdrawn
FROM applications
WHERE event_id = $1
`

type GetApplicationStatusSplitRow struct {
	Started     int64 `json:"started"`
	Submitted   int64 `json:"submitted"`
	UnderReview int64 `json:"under_review"`
	Accepted    int64 `json:"accepted"`
	Rejected    int64 `json:"rejected"`
	Waitlisted  int64 `json:"waitlisted"`
	Withdrawn   int64 `json:"withdrawn"`
}

func (q *Queries) GetApplicationStatusSplit(ctx context.Context, eventID uuid.UUID) (GetApplicationStatusSplitRow, error) {
	row := q.db.QueryRow(ctx, getApplicationStatusSplit, eventID)
	var i GetApplicationStatusSplitRow
	err := row.Scan(
		&i.Started,
		&i.Submitted,
		&i.UnderReview,
		&i.Accepted,
		&i.Rejected,
		&i.Waitlisted,
		&i.Withdrawn,
	)
	return i, err
}
