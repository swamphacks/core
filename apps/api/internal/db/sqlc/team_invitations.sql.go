// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: team_invitations.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const acceptInvitation = `-- name: AcceptInvitation :one
UPDATE team_invitations
SET
    status = 'ACCEPTED'::invitation_status,
    invited_user_id = $1::uuid,
    updated_at = NOW()
WHERE
    id = $2 AND 
    status = 'PENDING'::invitation_status AND 
    expires_at > NOW()
RETURNING id, team_id, invited_by_user_id, invited_email, invited_user_id, status, expires_at, created_at, updated_at
`

type AcceptInvitationParams struct {
	InvitedUserID uuid.UUID `json:"invited_user_id"`
	ID            uuid.UUID `json:"id"`
}

func (q *Queries) AcceptInvitation(ctx context.Context, arg AcceptInvitationParams) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, acceptInvitation, arg.InvitedUserID, arg.ID)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.InvitedByUserID,
		&i.InvitedEmail,
		&i.InvitedUserID,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO team_invitations (
    team_id, invited_by_user_id, invited_email, expires_at
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, team_id, invited_by_user_id, invited_email, invited_user_id, status, expires_at, created_at, updated_at
`

type CreateInvitationParams struct {
	TeamID          uuid.UUID  `json:"team_id"`
	InvitedByUserID uuid.UUID  `json:"invited_by_user_id"`
	InvitedEmail    string     `json:"invited_email"`
	ExpiresAt       *time.Time `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.TeamID,
		arg.InvitedByUserID,
		arg.InvitedEmail,
		arg.ExpiresAt,
	)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.InvitedByUserID,
		&i.InvitedEmail,
		&i.InvitedUserID,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM team_invitations 
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT id, team_id, invited_by_user_id, invited_email, invited_user_id, status, expires_at, created_at, updated_at FROM team_invitations 
WHERE id = $1
`

func (q *Queries) GetInvitationByID(ctx context.Context, id uuid.UUID) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByID, id)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.InvitedByUserID,
		&i.InvitedEmail,
		&i.InvitedUserID,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInvitationsByInvitedUserIDAndStatus = `-- name: ListInvitationsByInvitedUserIDAndStatus :many
SELECT id, team_id, invited_by_user_id, invited_email, invited_user_id, status, expires_at, created_at, updated_at
FROM team_invitations
WHERE invited_user_id = $1 AND status = $2::invitation_status
ORDER BY created_at DESC
`

type ListInvitationsByInvitedUserIDAndStatusParams struct {
	InvitedUserID *uuid.UUID       `json:"invited_user_id"`
	Status        InvitationStatus `json:"status"`
}

func (q *Queries) ListInvitationsByInvitedUserIDAndStatus(ctx context.Context, arg ListInvitationsByInvitedUserIDAndStatusParams) ([]TeamInvitation, error) {
	rows, err := q.db.Query(ctx, listInvitationsByInvitedUserIDAndStatus, arg.InvitedUserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamInvitation{}
	for rows.Next() {
		var i TeamInvitation
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.InvitedByUserID,
			&i.InvitedEmail,
			&i.InvitedUserID,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingInvitationsByTeam = `-- name: ListPendingInvitationsByTeam :many
SELECT id, team_id, invited_by_user_id, invited_email, invited_user_id, status, expires_at, created_at, updated_at
FROM team_invitations
WHERE team_id = $1 AND status = 'PENDING'::invitation_status
ORDER BY created_at DESC
`

func (q *Queries) ListPendingInvitationsByTeam(ctx context.Context, teamID uuid.UUID) ([]TeamInvitation, error) {
	rows, err := q.db.Query(ctx, listPendingInvitationsByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamInvitation{}
	for rows.Next() {
		var i TeamInvitation
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.InvitedByUserID,
			&i.InvitedEmail,
			&i.InvitedUserID,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectInvitation = `-- name: RejectInvitation :one
UPDATE team_invitations
SET
    status = 'REJECTED'::invitation_status,
    updated_at = NOW()
WHERE
    id = $1 AND 
    status = 'PENDING'::invitation_status AND 
    expires_at > NOW()
RETURNING id, team_id, invited_by_user_id, invited_email, invited_user_id, status, expires_at, created_at, updated_at
`

func (q *Queries) RejectInvitation(ctx context.Context, id uuid.UUID) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, rejectInvitation, id)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.InvitedByUserID,
		&i.InvitedEmail,
		&i.InvitedUserID,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInvitation = `-- name: UpdateInvitation :one
UPDATE team_invitations
SET
    invited_user_id = CASE WHEN $1::boolean THEN $2::uuid ELSE invited_user_id END,
    status = CASE WHEN $3::boolean THEN $4::invitation_status ELSE status END,
    expires_at = CASE WHEN $5::boolean THEN $6::timestamptz ELSE expires_at END,
    updated_at = NOW()
WHERE
    id = $7::uuid
RETURNING id, team_id, invited_by_user_id, invited_email, invited_user_id, status, expires_at, created_at, updated_at
`

type UpdateInvitationParams struct {
	InvitedUserIDDoUpdate bool             `json:"invited_user_id_do_update"`
	InvitedUserID         uuid.UUID        `json:"invited_user_id"`
	StatusDoUpdate        bool             `json:"status_do_update"`
	Status                InvitationStatus `json:"status"`
	ExpiresAtDoUpdate     bool             `json:"expires_at_do_update"`
	ExpiresAt             time.Time        `json:"expires_at"`
	ID                    uuid.UUID        `json:"id"`
}

func (q *Queries) UpdateInvitation(ctx context.Context, arg UpdateInvitationParams) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, updateInvitation,
		arg.InvitedUserIDDoUpdate,
		arg.InvitedUserID,
		arg.StatusDoUpdate,
		arg.Status,
		arg.ExpiresAtDoUpdate,
		arg.ExpiresAt,
		arg.ID,
	)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.InvitedByUserID,
		&i.InvitedEmail,
		&i.InvitedUserID,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
