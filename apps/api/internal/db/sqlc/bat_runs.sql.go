// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bat_runs.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addRun = `-- name: AddRun :one
INSERT INTO bat_runs (
    event_id
) VALUES (
    $1
) RETURNING id, event_id, accepted_applicants, rejected_applicants, status, created_at, completed_at
`

func (q *Queries) AddRun(ctx context.Context, eventID uuid.UUID) (BatRun, error) {
	row := q.db.QueryRow(ctx, addRun, eventID)
	var i BatRun
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.AcceptedApplicants,
		&i.RejectedApplicants,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteRunById = `-- name: DeleteRunById :execrows
DELETE FROM bat_runs
WHERE id = $1
`

func (q *Queries) DeleteRunById(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRunById, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getRunById = `-- name: GetRunById :one
SELECT id, event_id, accepted_applicants, rejected_applicants, status, created_at, completed_at
FROM bat_runs
WHERE id = $1
`

func (q *Queries) GetRunById(ctx context.Context, id uuid.UUID) (BatRun, error) {
	row := q.db.QueryRow(ctx, getRunById, id)
	var i BatRun
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.AcceptedApplicants,
		&i.RejectedApplicants,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getRunsByEventId = `-- name: GetRunsByEventId :many
SELECT
    id,
    accepted_applicants,
    rejected_applicants,
    status,
    created_at,
    completed_at
FROM bat_runs
WHERE event_id = $1
ORDER BY created_at DESC
`

type GetRunsByEventIdRow struct {
	ID                 uuid.UUID        `json:"id"`
	AcceptedApplicants []uuid.UUID      `json:"accepted_applicants"`
	RejectedApplicants []uuid.UUID      `json:"rejected_applicants"`
	Status             NullBatRunStatus `json:"status"`
	CreatedAt          time.Time        `json:"created_at"`
	CompletedAt        *time.Time       `json:"completed_at"`
}

func (q *Queries) GetRunsByEventId(ctx context.Context, eventID uuid.UUID) ([]GetRunsByEventIdRow, error) {
	rows, err := q.db.Query(ctx, getRunsByEventId, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRunsByEventIdRow{}
	for rows.Next() {
		var i GetRunsByEventIdRow
		if err := rows.Scan(
			&i.ID,
			&i.AcceptedApplicants,
			&i.RejectedApplicants,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRunById = `-- name: UpdateRunById :exec
UPDATE bat_runs
SET
    accepted_applicants = CASE WHEN $1::boolean THEN $2 ELSE accepted_applicants END,
    rejected_applicants = CASE WHEN $3::boolean THEN $4 ELSE rejected_applicants END,
    status = CASE WHEN $5::boolean THEN $6 ELSE status END,
    created_at = CASE WHEN $7::boolean THEN $8 ELSE created_at END
WHERE
    id = $9::uuid
RETURNING id, event_id, accepted_applicants, rejected_applicants, status, created_at, completed_at
`

type UpdateRunByIdParams struct {
	AcceptedApplicantsDoUpdate bool             `json:"accepted_applicants_do_update"`
	AcceptedApplicants         []uuid.UUID      `json:"accepted_applicants"`
	RejectedApplicantsDoUpdate bool             `json:"rejected_applicants_do_update"`
	RejectedApplicants         []uuid.UUID      `json:"rejected_applicants"`
	StatusDoUpdate             bool             `json:"status_do_update"`
	Status                     NullBatRunStatus `json:"status"`
	CreatedAtDoUpdate          bool             `json:"created_at_do_update"`
	CreatedAt                  time.Time        `json:"created_at"`
	ID                         uuid.UUID        `json:"id"`
}

func (q *Queries) UpdateRunById(ctx context.Context, arg UpdateRunByIdParams) error {
	_, err := q.db.Exec(ctx, updateRunById,
		arg.AcceptedApplicantsDoUpdate,
		arg.AcceptedApplicants,
		arg.RejectedApplicantsDoUpdate,
		arg.RejectedApplicants,
		arg.StatusDoUpdate,
		arg.Status,
		arg.CreatedAtDoUpdate,
		arg.CreatedAt,
		arg.ID,
	)
	return err
}
