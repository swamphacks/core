// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: team_join_requests.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createTeamJoinRequest = `-- name: CreateTeamJoinRequest :one
INSERT INTO team_join_requests (
    team_id, user_id, request_message
) VALUES (
    $1, $2, $3
)
RETURNING id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
`

type CreateTeamJoinRequestParams struct {
	TeamID         uuid.UUID `json:"team_id"`
	UserID         uuid.UUID `json:"user_id"`
	RequestMessage *string   `json:"request_message"`
}

func (q *Queries) CreateTeamJoinRequest(ctx context.Context, arg CreateTeamJoinRequestParams) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, createTeamJoinRequest, arg.TeamID, arg.UserID, arg.RequestMessage)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJoinRequest = `-- name: DeleteJoinRequest :exec
DELETE FROM team_join_requests 
WHERE id = $1
`

func (q *Queries) DeleteJoinRequest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteJoinRequest, id)
	return err
}

const deleteJoinRequestsByUserAndEventAndStatus = `-- name: DeleteJoinRequestsByUserAndEventAndStatus :exec
DELETE FROM team_join_requests tjr
WHERE tjr.user_id = $1
  AND tjr.status = $2
  AND EXISTS (
      SELECT 1
      FROM teams t
      WHERE t.id = tjr.team_id
        AND t.event_id = $3
  )
`

type DeleteJoinRequestsByUserAndEventAndStatusParams struct {
	UserID  uuid.UUID         `json:"user_id"`
	Status  JoinRequestStatus `json:"status"`
	EventID *uuid.UUID        `json:"event_id"`
}

func (q *Queries) DeleteJoinRequestsByUserAndEventAndStatus(ctx context.Context, arg DeleteJoinRequestsByUserAndEventAndStatusParams) error {
	_, err := q.db.Exec(ctx, deleteJoinRequestsByUserAndEventAndStatus, arg.UserID, arg.Status, arg.EventID)
	return err
}

const getTeamJoinRequestByID = `-- name: GetTeamJoinRequestByID :one
SELECT id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at FROM team_join_requests 
WHERE id = $1
`

func (q *Queries) GetTeamJoinRequestByID(ctx context.Context, id uuid.UUID) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, getTeamJoinRequestByID, id)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJoinRequestsByTeamAndStatusWithUser = `-- name: ListJoinRequestsByTeamAndStatusWithUser :many
SELECT 
    tjr.id, tjr.team_id, tjr.user_id, tjr.request_message, tjr.status, tjr.processed_by_user_id, tjr.processed_at, tjr.created_at, tjr.updated_at,
    u.email AS user_email,
    u.name AS user_name,
    u.image AS user_image
FROM team_join_requests tjr
JOIN auth.users u ON u.id = tjr.user_id
WHERE tjr.team_id = $1::uuid
    AND tjr.status = $2::join_request_status
ORDER BY tjr.created_at DESC
`

type ListJoinRequestsByTeamAndStatusWithUserParams struct {
	TeamID uuid.UUID         `json:"team_id"`
	Status JoinRequestStatus `json:"status"`
}

type ListJoinRequestsByTeamAndStatusWithUserRow struct {
	ID                uuid.UUID         `json:"id"`
	TeamID            uuid.UUID         `json:"team_id"`
	UserID            uuid.UUID         `json:"user_id"`
	RequestMessage    *string           `json:"request_message"`
	Status            JoinRequestStatus `json:"status"`
	ProcessedByUserID *uuid.UUID        `json:"processed_by_user_id"`
	ProcessedAt       *time.Time        `json:"processed_at"`
	CreatedAt         time.Time         `json:"created_at"`
	UpdatedAt         time.Time         `json:"updated_at"`
	UserEmail         *string           `json:"user_email"`
	UserName          string            `json:"user_name"`
	UserImage         *string           `json:"user_image"`
}

func (q *Queries) ListJoinRequestsByTeamAndStatusWithUser(ctx context.Context, arg ListJoinRequestsByTeamAndStatusWithUserParams) ([]ListJoinRequestsByTeamAndStatusWithUserRow, error) {
	rows, err := q.db.Query(ctx, listJoinRequestsByTeamAndStatusWithUser, arg.TeamID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListJoinRequestsByTeamAndStatusWithUserRow{}
	for rows.Next() {
		var i ListJoinRequestsByTeamAndStatusWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.UserID,
			&i.RequestMessage,
			&i.Status,
			&i.ProcessedByUserID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserEmail,
			&i.UserName,
			&i.UserImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamJoinRequestsByTeamIDAndStatus = `-- name: ListTeamJoinRequestsByTeamIDAndStatus :many
SELECT id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
FROM team_join_requests
WHERE team_id = $1 AND status = $2::join_request_status
ORDER BY created_at DESC
`

type ListTeamJoinRequestsByTeamIDAndStatusParams struct {
	TeamID uuid.UUID         `json:"team_id"`
	Status JoinRequestStatus `json:"status"`
}

func (q *Queries) ListTeamJoinRequestsByTeamIDAndStatus(ctx context.Context, arg ListTeamJoinRequestsByTeamIDAndStatusParams) ([]TeamJoinRequest, error) {
	rows, err := q.db.Query(ctx, listTeamJoinRequestsByTeamIDAndStatus, arg.TeamID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamJoinRequest{}
	for rows.Next() {
		var i TeamJoinRequest
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.UserID,
			&i.RequestMessage,
			&i.Status,
			&i.ProcessedByUserID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamJoinRequestsByUserAndEventAndStatus = `-- name: ListTeamJoinRequestsByUserAndEventAndStatus :many
SELECT tjr.id, tjr.team_id, tjr.user_id, tjr.request_message, tjr.status, tjr.processed_by_user_id, tjr.processed_at, tjr.created_at, tjr.updated_at
FROM team_join_requests tjr
WHERE tjr.user_id = $1
  AND tjr.status = $2
  AND EXISTS (
      SELECT 1
      FROM teams t
      WHERE t.id = tjr.team_id
        AND t.event_id = $3
  )
ORDER BY tjr.created_at DESC
`

type ListTeamJoinRequestsByUserAndEventAndStatusParams struct {
	UserID  uuid.UUID         `json:"user_id"`
	Status  JoinRequestStatus `json:"status"`
	EventID *uuid.UUID        `json:"event_id"`
}

func (q *Queries) ListTeamJoinRequestsByUserAndEventAndStatus(ctx context.Context, arg ListTeamJoinRequestsByUserAndEventAndStatusParams) ([]TeamJoinRequest, error) {
	rows, err := q.db.Query(ctx, listTeamJoinRequestsByUserAndEventAndStatus, arg.UserID, arg.Status, arg.EventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamJoinRequest{}
	for rows.Next() {
		var i TeamJoinRequest
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.UserID,
			&i.RequestMessage,
			&i.Status,
			&i.ProcessedByUserID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamJoinRequestsByUserID = `-- name: ListTeamJoinRequestsByUserID :many
SELECT id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
FROM team_join_requests
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListTeamJoinRequestsByUserID(ctx context.Context, userID uuid.UUID) ([]TeamJoinRequest, error) {
	rows, err := q.db.Query(ctx, listTeamJoinRequestsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamJoinRequest{}
	for rows.Next() {
		var i TeamJoinRequest
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.UserID,
			&i.RequestMessage,
			&i.Status,
			&i.ProcessedByUserID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTeamJoinRequest = `-- name: UpdateTeamJoinRequest :one
UPDATE team_join_requests
SET
    request_message = CASE WHEN $1::boolean THEN $2 ELSE request_message END,
    status = CASE WHEN $3::boolean THEN $4::join_request_status ELSE status END,
    processed_by_user_id = CASE WHEN $5::boolean THEN $6::uuid ELSE processed_by_user_id END,
    processed_at = CASE WHEN $7::boolean THEN $8::timestamptz ELSE processed_at END,
    updated_at = NOW()
WHERE
    id = $9::uuid
RETURNING id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
`

type UpdateTeamJoinRequestParams struct {
	RequestMessageDoUpdate    bool              `json:"request_message_do_update"`
	RequestMessage            *string           `json:"request_message"`
	StatusDoUpdate            bool              `json:"status_do_update"`
	Status                    JoinRequestStatus `json:"status"`
	ProcessedByUserIDDoUpdate bool              `json:"processed_by_user_id_do_update"`
	ProcessedByUserID         uuid.UUID         `json:"processed_by_user_id"`
	ProcessedAtDoUpdate       bool              `json:"processed_at_do_update"`
	ProcessedAt               time.Time         `json:"processed_at"`
	ID                        uuid.UUID         `json:"id"`
}

func (q *Queries) UpdateTeamJoinRequest(ctx context.Context, arg UpdateTeamJoinRequestParams) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, updateTeamJoinRequest,
		arg.RequestMessageDoUpdate,
		arg.RequestMessage,
		arg.StatusDoUpdate,
		arg.Status,
		arg.ProcessedByUserIDDoUpdate,
		arg.ProcessedByUserID,
		arg.ProcessedAtDoUpdate,
		arg.ProcessedAt,
		arg.ID,
	)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
