// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: team_join_requests.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const approveJoinRequest = `-- name: ApproveJoinRequest :one
UPDATE team_join_requests
SET
    status = 'APPROVED'::join_request_status,
    processed_by_user_id = $1::uuid,
    processed_at = NOW(),
    updated_at = NOW()
WHERE
    id = $2 AND 
    status = 'PENDING'::join_request_status
RETURNING id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
`

type ApproveJoinRequestParams struct {
	ProcessedByUserID uuid.UUID `json:"processed_by_user_id"`
	ID                uuid.UUID `json:"id"`
}

func (q *Queries) ApproveJoinRequest(ctx context.Context, arg ApproveJoinRequestParams) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, approveJoinRequest, arg.ProcessedByUserID, arg.ID)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createJoinRequest = `-- name: CreateJoinRequest :one
INSERT INTO team_join_requests (
    team_id, user_id, request_message
) VALUES (
    $1, $2, $3
)
RETURNING id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
`

type CreateJoinRequestParams struct {
	TeamID         uuid.UUID `json:"team_id"`
	UserID         uuid.UUID `json:"user_id"`
	RequestMessage *string   `json:"request_message"`
}

func (q *Queries) CreateJoinRequest(ctx context.Context, arg CreateJoinRequestParams) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, createJoinRequest, arg.TeamID, arg.UserID, arg.RequestMessage)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJoinRequest = `-- name: DeleteJoinRequest :exec
DELETE FROM team_join_requests 
WHERE id = $1
`

func (q *Queries) DeleteJoinRequest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteJoinRequest, id)
	return err
}

const getJoinRequestByID = `-- name: GetJoinRequestByID :one
SELECT id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at FROM team_join_requests 
WHERE id = $1
`

func (q *Queries) GetJoinRequestByID(ctx context.Context, id uuid.UUID) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, getJoinRequestByID, id)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJoinRequestsByTeamIDAndStatus = `-- name: ListJoinRequestsByTeamIDAndStatus :many
SELECT id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
FROM team_join_requests
WHERE team_id = $1 AND status = $2::join_request_status
ORDER BY created_at DESC
`

type ListJoinRequestsByTeamIDAndStatusParams struct {
	TeamID uuid.UUID         `json:"team_id"`
	Status JoinRequestStatus `json:"status"`
}

func (q *Queries) ListJoinRequestsByTeamIDAndStatus(ctx context.Context, arg ListJoinRequestsByTeamIDAndStatusParams) ([]TeamJoinRequest, error) {
	rows, err := q.db.Query(ctx, listJoinRequestsByTeamIDAndStatus, arg.TeamID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamJoinRequest{}
	for rows.Next() {
		var i TeamJoinRequest
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.UserID,
			&i.RequestMessage,
			&i.Status,
			&i.ProcessedByUserID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJoinRequestsByUserID = `-- name: ListJoinRequestsByUserID :many
SELECT id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
FROM team_join_requests
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListJoinRequestsByUserID(ctx context.Context, userID uuid.UUID) ([]TeamJoinRequest, error) {
	rows, err := q.db.Query(ctx, listJoinRequestsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamJoinRequest{}
	for rows.Next() {
		var i TeamJoinRequest
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.UserID,
			&i.RequestMessage,
			&i.Status,
			&i.ProcessedByUserID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectJoinRequest = `-- name: RejectJoinRequest :one
UPDATE team_join_requests
SET
    status = 'REJECTED'::join_request_status,
    processed_by_user_id = $1::uuid,
    processed_at = NOW(),
    updated_at = NOW()
WHERE
    id = $2 AND 
    status = 'PENDING'::join_request_status
RETURNING id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
`

type RejectJoinRequestParams struct {
	ProcessedByUserID uuid.UUID `json:"processed_by_user_id"`
	ID                uuid.UUID `json:"id"`
}

func (q *Queries) RejectJoinRequest(ctx context.Context, arg RejectJoinRequestParams) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, rejectJoinRequest, arg.ProcessedByUserID, arg.ID)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJoinRequest = `-- name: UpdateJoinRequest :one
UPDATE team_join_requests
SET
    request_message = CASE WHEN $1::boolean THEN $2 ELSE request_message END,
    status = CASE WHEN $3::boolean THEN $4::join_request_status ELSE status END,
    processed_by_user_id = CASE WHEN $5::boolean THEN $6::uuid ELSE processed_by_user_id END,
    processed_at = CASE WHEN $7::boolean THEN $8::timestamptz ELSE processed_at END,
    updated_at = NOW()
WHERE
    id = $9::uuid
RETURNING id, team_id, user_id, request_message, status, processed_by_user_id, processed_at, created_at, updated_at
`

type UpdateJoinRequestParams struct {
	RequestMessageDoUpdate    bool              `json:"request_message_do_update"`
	RequestMessage            *string           `json:"request_message"`
	StatusDoUpdate            bool              `json:"status_do_update"`
	Status                    JoinRequestStatus `json:"status"`
	ProcessedByUserIDDoUpdate bool              `json:"processed_by_user_id_do_update"`
	ProcessedByUserID         uuid.UUID         `json:"processed_by_user_id"`
	ProcessedAtDoUpdate       bool              `json:"processed_at_do_update"`
	ProcessedAt               time.Time         `json:"processed_at"`
	ID                        uuid.UUID         `json:"id"`
}

func (q *Queries) UpdateJoinRequest(ctx context.Context, arg UpdateJoinRequestParams) (TeamJoinRequest, error) {
	row := q.db.QueryRow(ctx, updateJoinRequest,
		arg.RequestMessageDoUpdate,
		arg.RequestMessage,
		arg.StatusDoUpdate,
		arg.Status,
		arg.ProcessedByUserIDDoUpdate,
		arg.ProcessedByUserID,
		arg.ProcessedAtDoUpdate,
		arg.ProcessedAt,
		arg.ID,
	)
	var i TeamJoinRequest
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.UserID,
		&i.RequestMessage,
		&i.Status,
		&i.ProcessedByUserID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
