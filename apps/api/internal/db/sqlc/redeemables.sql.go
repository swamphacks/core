// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: redeemables.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createRedeemable = `-- name: CreateRedeemable :one
INSERT INTO redeemables (event_id, name, amount, max_user_amount)
VALUES ($1, $2, $3, $4)
RETURNING id, event_id, name, amount, max_user_amount, created_at, updated_at
`

type CreateRedeemableParams struct {
	EventID       uuid.UUID `json:"event_id"`
	Name          string    `json:"name"`
	Amount        int32     `json:"amount"`
	MaxUserAmount int32     `json:"max_user_amount"`
}

// Create a new redeemable for an event
func (q *Queries) CreateRedeemable(ctx context.Context, arg CreateRedeemableParams) (Redeemable, error) {
	row := q.db.QueryRow(ctx, createRedeemable,
		arg.EventID,
		arg.Name,
		arg.Amount,
		arg.MaxUserAmount,
	)
	var i Redeemable
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Amount,
		&i.MaxUserAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRedeemable = `-- name: DeleteRedeemable :exec
DELETE FROM redeemables
WHERE id = $1
`

// Delete a redeemable by id
func (q *Queries) DeleteRedeemable(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRedeemable, id)
	return err
}

const getRedeemablesByEventID = `-- name: GetRedeemablesByEventID :many
SELECT r.id, 
r.event_id, 
r.name, 
r.amount AS total_stock, 
r.max_user_amount,
r.created_at, 
r.updated_at,
COALESCE(SUM(ur.amount), 0) AS total_redeemed
FROM redeemables r
LEFT JOIN user_redemptions ur ON r.id = ur.redeemable_id
WHERE r.event_id = $1
GROUP BY r.id
`

type GetRedeemablesByEventIDRow struct {
	ID            uuid.UUID          `json:"id"`
	EventID       uuid.UUID          `json:"event_id"`
	Name          string             `json:"name"`
	TotalStock    int32              `json:"total_stock"`
	MaxUserAmount int32              `json:"max_user_amount"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	TotalRedeemed interface{}        `json:"total_redeemed"`
}

// Using event id, return all redeemables associated. Should also return data like how many have been redeemed already
func (q *Queries) GetRedeemablesByEventID(ctx context.Context, eventID uuid.UUID) ([]GetRedeemablesByEventIDRow, error) {
	rows, err := q.db.Query(ctx, getRedeemablesByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRedeemablesByEventIDRow{}
	for rows.Next() {
		var i GetRedeemablesByEventIDRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.TotalStock,
			&i.MaxUserAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRedeemed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedemptionInfoByRedeemableID = `-- name: GetRedemptionInfoByRedeemableID :many
SELECT ur.user_id, ur.redeemable_id, ur.amount, ur.created_at, ur.updated_at
FROM user_redemptions ur
WHERE ur.redeemable_id = $1
`

// Gather all redemption info for a specific reedeemable (who has redeemed already)
func (q *Queries) GetRedemptionInfoByRedeemableID(ctx context.Context, redeemableID uuid.UUID) ([]UserRedemption, error) {
	rows, err := q.db.Query(ctx, getRedemptionInfoByRedeemableID, redeemableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserRedemption{}
	for rows.Next() {
		var i UserRedemption
		if err := rows.Scan(
			&i.UserID,
			&i.RedeemableID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const redeemRedeemable = `-- name: RedeemRedeemable :one
INSERT INTO user_redemptions (user_id, redeemable_id, amount)
SELECT $1, $2, 1
WHERE (
    SELECT COALESCE(SUM(amount), 0) 
    FROM user_redemptions 
    WHERE redeemable_id = $2
) < (SELECT amount FROM redeemables WHERE id = $2)
ON CONFLICT (user_id, redeemable_id) 
DO UPDATE SET 
    amount = user_redemptions.amount + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE user_redemptions.amount < (SELECT max_user_amount FROM redeemables WHERE id = $2)
RETURNING user_id, redeemable_id, amount, created_at, updated_at
`

type RedeemRedeemableParams struct {
	UserID       uuid.UUID `json:"user_id"`
	RedeemableID uuid.UUID `json:"redeemable_id"`
}

// Using user id and redeemable id, attempt! to redeem a redeemable
func (q *Queries) RedeemRedeemable(ctx context.Context, arg RedeemRedeemableParams) (UserRedemption, error) {
	row := q.db.QueryRow(ctx, redeemRedeemable, arg.UserID, arg.RedeemableID)
	var i UserRedemption
	err := row.Scan(
		&i.UserID,
		&i.RedeemableID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRedeemable = `-- name: UpdateRedeemable :one
UPDATE redeemables
SET 
    name = COALESCE($2, name),
    amount = COALESCE($3, amount),
    max_user_amount = COALESCE($4, max_user_amount),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, event_id, name, amount, max_user_amount, created_at, updated_at
`

type UpdateRedeemableParams struct {
	ID            uuid.UUID `json:"id"`
	Name          *string   `json:"name"`
	Amount        *int32    `json:"amount"`
	MaxUserAmount *int32    `json:"max_user_amount"`
}

func (q *Queries) UpdateRedeemable(ctx context.Context, arg UpdateRedeemableParams) (Redeemable, error) {
	row := q.db.QueryRow(ctx, updateRedeemable,
		arg.ID,
		arg.Name,
		arg.Amount,
		arg.MaxUserAmount,
	)
	var i Redeemable
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Amount,
		&i.MaxUserAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRedemption = `-- name: UpdateRedemption :exec
UPDATE user_redemptions
SET
    amount = $1
WHERE user_id = $2 AND redeemable_id = $3
`

type UpdateRedemptionParams struct {
	Amount       int32     `json:"amount"`
	UserID       uuid.UUID `json:"user_id"`
	RedeemableID uuid.UUID `json:"redeemable_id"`
}

// Update a redemption record for a user and redeemable (for removing redemption mostly)
func (q *Queries) UpdateRedemption(ctx context.Context, arg UpdateRedemptionParams) error {
	_, err := q.db.Exec(ctx, updateRedemption, arg.Amount, arg.UserID, arg.RedeemableID)
	return err
}
